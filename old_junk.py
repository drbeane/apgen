      
    def generate_qti_OLD(self, path='', quiz_version='new', print_versions=0, 
                     make_file=True, generate_zip=False):
        import os
        
        if len(self.versions) == 0:
            print('No versions have been generated. Please call the generate() method.')
            return
        
        qti_text = f'Quiz title: {self.id}\n'
        qti_text += 'Quiz description: Generated by ExSam.\n\n'
        
        for i, v in enumerate(self.versions):
            
            version_text = self.versions[i]['text']
            #if quiz_version == 'new':
            #    version_text = self.versions[i]['text_new']
            #elif quiz_version == 'old':
            #    version_text = self.versions[i]['text_old']
            #else:
            #    print('Quiz version not recognized.')
            #    return
            
            #if quiz_version == 'new':
                #version_text = version_text.replace('</p>', '<br/><br/></p>\n')
                #version_text = version_text.replace('</table>', '</table><p>&nbsp;</p>')
                        
            num_len = len(str(i+1))
            spaces = ' ' * (num_len + 2)
                        
            version_text = version_text.replace('\n', f'\n{spaces}')
            
            qti_text += f'Title: Version {i+1}\n'
            qti_text += f'Points: 1\n'
            qti_text += f'{i+1}. {version_text}'
            
            answer_options = self.versions[i]['answer_options']
            
            # Add Multiple Choice Answer Options
            if self.type == 'MC':
                letters = list('abcdefghijklmnopqrstuvwzyz')
                for j, ao in enumerate(answer_options):
                    x = letters[j]
                    if x == 'a': x = '*a'
                    qti_text += f'{x}) {ao}\n' 

            # Add Multiple Answer Options
            if self.type == 'MA':
                for j, ao in enumerate(answer_options):
                    ao_mod = ao.replace('[X]', '[*]')
                    qti_text += f'{ao_mod}\n' 
            
                                            
            # Add Numerical Answer
            elif self.type == 'NUM':
                ans = answer_options[0]
                qti_text += f'=   {ans} +- {self.margin}'
                        
            qti_text += '\n\n'
            
            if i+1 == print_versions:    
                print(qti_text)
        
        if make_file:
            if path != '':
                if path[-1] != '/':
                    path = path + '/'
            
                if not os.path.exists(path):
                    os.mkdir(path)
                
            with open(f'{path}{self.id}.txt', 'w') as file:
                file.write(qti_text)
            
        if generate_zip:
            import subprocess
            
            cmd = f'text2qti "{path}{self.id}.txt"'           
            result = subprocess.run(cmd, capture_output=True, text=True, shell=True)
        
            if result.returncode != 0:
                print(result.returncode)
                print()
                print(result.stdout)
                print()
                print(result.stderr)
            else:
                print('QTI zip generated successfully!')
        

    def generate_qti_2(self, path='', quiz_version='new', print_versions=0, 
                     make_file=True, generate_zip=False):
        import os
        
        if len(self.versions) == 0:
            print('No versions have been generated. Please call the generate() method.')
            return
        
        qti_text = ''
        
        for i, v in enumerate(self.versions):
            
            version_text = self.versions[i]['text']
            version_text = version_text.replace('\n', '')

            #num_len = len(str(i+1))
            #spaces = ' ' * (num_len + 2)
            #version_text = version_text.replace('\n', f'\n{spaces}')
            
            #qti_text += f'Title: Version {i+1}\n'
            #qti_text += f'Points: 1\n'
            qti_text += 'MT\n'
            qti_text += f'{i+1}. {version_text}\n'
            
            answer_options = self.versions[i]['answer_options']
            
            # Add Multiple Choice Answer Options
            if self.type == 'MC':
                letters = list('abcdefghijklmnopqrstuvwzyz')
                for j, ao in enumerate(answer_options):
                    x = letters[j]
                    if x == 'a': x = '*a'
                    qti_text += f'{x}) {ao}\n' 

            # Add Multiple Answer Options
            if self.type == 'MA':
                for j, ao in enumerate(answer_options):
                    ao_mod = ao.replace('[X]', '[*]')
                    qti_text += f'{ao_mod}\n' 
            
                                            
            # Add Numerical Answer
            elif self.type == 'NUM':
                ans = answer_options[0]
                qti_text += f'=   {ans} +- {self.margin}'
        
            elif self.type == 'MT':
                left = []
                right = []  
                LtoR = []
                for j, ao in enumerate(answer_options):
                    if ':' in ao:
                        L, R = ao.split(':')
                        L = L.strip()
                        R = R.strip()
                        left.append(L)
                        if R not in right:
                            right.append(R)
                        k = right.index(R) + 1
                        LtoR.append(k)
                    else:
                        R = ao.strip()
                        if R not in right:
                            right.append(R)
                for k, L in enumerate(left):
                    Rn = LtoR[k]
                    qti_text += f'[right{Rn}]left{k+1}: {L}\n'
                for k, R in enumerate(right):
                    qti_text += f'right{k+1}: {R}\n'
                
            qti_text += '\n\n'
            
            if i+1 == print_versions:    
                print(qti_text)
        
        if make_file:
            if path != '':
                if path[-1] != '/':
                    path = path + '/'
            
                if not os.path.exists(path):
                    os.mkdir(path)
                
            with open(f'{path}{self.id}.txt', 'w') as file:
                file.write(qti_text)
            
        if generate_zip:
            import subprocess
            
            if self.type == 'MT':
                cmd = f'python qtiConverter/qtiConverterApp.py "{path}{self.id}.txt"'
            else:
                cmd = f'text2qti "{path}{self.id}.txt"'
            
            
            result = subprocess.run(cmd, capture_output=True, text=True, shell=True)
        
            if result.returncode != 0:
                print(result.returncode)
                print()
                print(result.stdout)
                print()
                print(result.stderr)
            else:
                print('QTI zip generated successfully!')
        
